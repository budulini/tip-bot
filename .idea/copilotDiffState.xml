<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/game_deals.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_deals.py" />
              <option name="updatedContent" value="import aiohttp&#10;import asyncio&#10;import discord&#10;from discord.ext import tasks&#10;import logging&#10;from datetime import datetime&#10;import json&#10;import os&#10;&#10;# Configuration - you can modify these variables&#10;REDDIT_SUBREDDIT = &quot;GameDeals&quot;  # The subreddit to monitor&#10;DEALS_CHANNEL_ID = 1364245813533868122  # Replace with your channel ID&#10;CHECK_INTERVAL_MINUTES = 30  # How often to check for new deals&#10;USER_AGENT = &quot;DiscordTipBot-GameDeals/1.0 (by /u/YourRedditUsername)&quot;  # User agent for Reddit API&#10;&#10;class GameDealsClient:&#10;    def __init__(self, bot):&#10;        self.bot = bot&#10;        self.session = None&#10;        self.last_deal_id = None&#10;        self.is_monitoring = False  # Flag to prevent multiple instances&#10;        self.load_last_deal_id()&#10;&#10;    async def get_session(self):&#10;        if self.session is None or self.session.closed:&#10;            self.session = aiohttp.ClientSession(&#10;                timeout=aiohttp.ClientTimeout(total=10),&#10;                headers={&quot;User-Agent&quot;: USER_AGENT}&#10;            )&#10;        return self.session&#10;&#10;    def load_last_deal_id(self):&#10;        &quot;&quot;&quot;Load the last deal ID from file to avoid duplicate notifications&quot;&quot;&quot;&#10;        try:&#10;            # Create files directory if it doesn't exist&#10;            os.makedirs('files', exist_ok=True)&#10;            with open('files/last_deal.json', 'r') as f:&#10;                data = json.load(f)&#10;                self.last_deal_id = data.get('last_deal_id')&#10;                logging.info(f&quot;Loaded last deal ID: {self.last_deal_id}&quot;)&#10;        except (FileNotFoundError, json.JSONDecodeError):&#10;            self.last_deal_id = None&#10;            logging.info(&quot;No previous deal ID found, starting fresh&quot;)&#10;&#10;    def save_last_deal_id(self, deal_id):&#10;        &quot;&quot;&quot;Save the last deal ID to file&quot;&quot;&quot;&#10;        try:&#10;            os.makedirs('files', exist_ok=True)&#10;            with open('files/last_deal.json', 'w') as f:&#10;                json.dump({'last_deal_id': deal_id}, f)&#10;            self.last_deal_id = deal_id&#10;            logging.info(f&quot;Saved last deal ID: {deal_id}&quot;)&#10;        except Exception as e:&#10;            logging.error(f&quot;Error saving last deal ID: {e}&quot;)&#10;&#10;    async def get_latest_deal_from_reddit(self):&#10;        &quot;&quot;&quot;Fetch the latest game deal from Reddit&quot;&quot;&quot;&#10;        try:&#10;            session = await self.get_session()&#10;            url = f&quot;https://www.reddit.com/r/{REDDIT_SUBREDDIT}/new.json?limit=10&quot;&#10;            &#10;            async with session.get(url) as response:&#10;                if response.status == 200:&#10;                    data = await response.json()&#10;                    posts = data.get('data', {}).get('children', [])&#10;                    &#10;                    for post in posts:&#10;                        post_data = post.get('data', {})&#10;                        title = post_data.get('title', '').lower()&#10;                        &#10;                        # Filter for actual deals (you can adjust these filters)&#10;                        deal_keywords = ['free', 'sale', 'deal', 'discount', '%', 'off', 'steam', 'epic', 'gog', 'humble']&#10;                        if any(keyword in title for keyword in deal_keywords):&#10;                            return {&#10;                                'redditId': post_data.get('id'),&#10;                                'redditTitle': post_data.get('title', 'No title'),&#10;                                'gameUrl': post_data.get('url', ''),&#10;                                'createdAt': datetime.fromtimestamp(post_data.get('created_utc', 0)).strftime('%Y-%m-%d %H:%M:%S'),&#10;                                'permalink': f&quot;https://reddit.com{post_data.get('permalink', '')}&quot;&#10;                            }&#10;                    &#10;                    logging.info(&quot;No new deals found in recent posts&quot;)&#10;                    return None&#10;                else:&#10;                    logging.error(f&quot;Reddit API returned status {response.status}&quot;)&#10;                    return None&#10;        except Exception as e:&#10;            logging.error(f&quot;Error fetching latest deal from Reddit: {e}&quot;)&#10;            return None&#10;&#10;    def format_deal_message(self, deal):&#10;        &quot;&quot;&quot;Format a deal into a Discord message&quot;&quot;&quot;&#10;        created_at = deal.get('createdAt', 'Unknown')&#10;        title = deal.get('redditTitle', 'No title')&#10;        game_url = deal.get('gameUrl', '')&#10;        permalink = deal.get('permalink', '')&#10;        &#10;        message = f&quot; **New Game Deal Found!**\n\n&quot;&#10;        message += f&quot; **Found at:** {created_at}\n&quot;&#10;        message += f&quot;**{title}**\n&quot;&#10;        if game_url and game_url != permalink:&#10;            message += f&quot; **Store:** &lt;{game_url}&gt;\n&quot;&#10;        if permalink:&#10;            message += f&quot; **Reddit:** {permalink}&quot;&#10;        &#10;        return message&#10;&#10;    async def send_deal_notification(self, deal):&#10;        &quot;&quot;&quot;Send a deal notification to the specified channel&quot;&quot;&quot;&#10;        try:&#10;            channel = self.bot.get_channel(DEALS_CHANNEL_ID)&#10;            if not channel:&#10;                logging.error(f&quot;Could not find channel with ID {DEALS_CHANNEL_ID}&quot;)&#10;                return&#10;&#10;            message = self.format_deal_message(deal)&#10;            await channel.send(message)&#10;            logging.info(f&quot;Sent deal notification: {deal.get('redditTitle', 'Unknown')}&quot;)&#10;            &#10;        except Exception as e:&#10;            logging.error(f&quot;Error sending deal notification: {e}&quot;)&#10;&#10;    @tasks.loop(minutes=CHECK_INTERVAL_MINUTES)&#10;    async def check_for_new_deals(self):&#10;        &quot;&quot;&quot;Periodically check for new deals and send notifications&quot;&quot;&quot;&#10;        try:&#10;            logging.info(&quot;Checking for new game deals...&quot;)&#10;            deal = await self.get_latest_deal_from_reddit()&#10;            if not deal:&#10;                logging.info(&quot;No new deals found&quot;)&#10;                return&#10;&#10;            deal_id = deal.get('redditId')&#10;            if deal_id and deal_id != self.last_deal_id:&#10;                await self.send_deal_notification(deal)&#10;                self.save_last_deal_id(deal_id)&#10;            else:&#10;                logging.info(f&quot;Deal {deal_id} already processed&quot;)&#10;                &#10;        except Exception as e:&#10;            logging.error(f&quot;Error in check_for_new_deals: {e}&quot;)&#10;&#10;    @check_for_new_deals.before_loop&#10;    async def before_check_for_new_deals(self):&#10;        &quot;&quot;&quot;Wait for the bot to be ready before starting the loop&quot;&quot;&quot;&#10;        await self.bot.wait_until_ready()&#10;        logging.info(&quot;Game deals monitoring is ready to start&quot;)&#10;&#10;    def start_monitoring(self):&#10;        &quot;&quot;&quot;Start monitoring for new deals (only if not already running)&quot;&quot;&quot;&#10;        if not self.is_monitoring and not self.check_for_new_deals.is_running():&#10;            self.check_for_new_deals.start()&#10;            self.is_monitoring = True&#10;            logging.info(f&quot;Started automatic game deals monitoring from r/{REDDIT_SUBREDDIT}&quot;)&#10;            logging.info(f&quot;Will check every {CHECK_INTERVAL_MINUTES} minutes&quot;)&#10;            logging.info(f&quot;Will post to channel ID: {DEALS_CHANNEL_ID}&quot;)&#10;        else:&#10;            logging.info(&quot;Game deals monitoring is already running&quot;)&#10;&#10;    def stop_monitoring(self):&#10;        &quot;&quot;&quot;Stop monitoring for new deals&quot;&quot;&quot;&#10;        if self.check_for_new_deals.is_running():&#10;            self.check_for_new_deals.cancel()&#10;        self.is_monitoring = False&#10;        logging.info(&quot;Stopped game deals monitoring&quot;)&#10;&#10;    async def close(self):&#10;        &quot;&quot;&quot;Clean up resources&quot;&quot;&quot;&#10;        self.stop_monitoring()&#10;        if self.session and not self.session.closed:&#10;            await self.session.close()&#10;&#10;def setup_game_deals(bot):&#10;    &quot;&quot;&quot;Set up game deals monitoring and return the client instance&quot;&quot;&quot;&#10;    logging.info(&quot;Setting up game deals monitoring...&quot;)&#10;    deals_client = GameDealsClient(bot)&#10;    &#10;    # Start monitoring automatically&#10;    deals_client.start_monitoring()&#10;    &#10;    return deals_client" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>